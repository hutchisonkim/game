using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core;
// Domain-agnostic pattern DTO used by the core move query system
public record PatternDto((int X, int Y) Vector,
    MirrorBehavior Mirrors = MirrorBehavior.All,
    RepeatBehavior Repeats = RepeatBehavior.Repeatable,
    CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
    bool ForwardOnly = false,
    bool Jumps = false
);

[Flags]
public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

// A candidate move generated by the builder before final filtering
public sealed record ActionCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping)
{
}

// Object-oriented actors for move expansion and filtering. These are domain-agnostic
// and operate using delegates supplied for board interrogation and faction info.

// A minimal interface for any actor that can produce move candidates
public interface IActor
{
    IEnumerable<ActionCandidate> GetActionCandidates();
}

// Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
public interface IPolicy
{
    IEnumerable<ActionCandidate> Apply(IEnumerable<ActionCandidate> candidates);
}

// Faction-level policy abstraction: used by FactionActor to provide faction-specific info
public interface IFactionPolicy
{
    // Returns the forward axis multiplier for the faction as a vector (X,Y)
    (int X, int Y) GetForwardAxis();
}

// Delegate-based faction policy
public sealed class DelegateFactionPolicy : IFactionPolicy
{
    private readonly Func<(int X, int Y)> _getForwardAxis;
    public DelegateFactionPolicy(Func<(int X, int Y)> getForwardAxis) => _getForwardAxis = getForwardAxis;
    public (int X, int Y) GetForwardAxis() => _getForwardAxis();
}

// FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
public sealed class FactionActor
{
    private readonly IFactionPolicy _policy;
    public FactionActor(IFactionPolicy policy) => _policy = policy;
    public (int X, int Y) GetForwardAxis() => _policy.GetForwardAxis();
}

// CellActor: domain-agnostic representation of a board cell (row/col)
// CellActor now implements IMoveActor and may hold an optional PieceActor to which it delegates move expansion
public sealed class CellActor : IActor
{
    public int Row { get; }
    public int Col { get; }
    public PieceActor? OccupyingPiece { get; set; }

    public CellActor(int row, int col)
    {
        Row = row;
        Col = col;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        if (OccupyingPiece == null) yield break;
        foreach (ActionCandidate cand in OccupyingPiece.GetCandidates(Row, Col))
            yield return cand;
    }
}


// Piece-level policy: responsible for supplying pattern DTOs for a piece
public interface IPiecePolicy
{
    IEnumerable<PatternDto> GetPatterns();
}

// Delegate-based piece policy
public sealed class DelegatePiecePolicy : IPiecePolicy
{
    private readonly Func<IEnumerable<PatternDto>> _getBasePatterns;
    public DelegatePiecePolicy(Func<IEnumerable<PatternDto>> getBasePatterns) => _getBasePatterns = getBasePatterns;

    public IEnumerable<PatternDto> GetPatterns()
    {
        // Expand mirrors behind the policy. Faction parameter is provided for policies
        // that need to filter or transform patterns by faction (not used here yet).
        foreach (PatternDto basePattern in _getBasePatterns())
        {
            foreach (PatternDto mirroredPattern in GetMirroredPatterns(basePattern))
            {
                yield return mirroredPattern;
            }
        }
    }
    
    public static IEnumerable<PatternDto> GetMirroredPatterns(PatternDto pattern)
    {
        yield return new PatternDto(pattern.Vector, MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return new PatternDto((-pattern.Vector.X, pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return new PatternDto((pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return new PatternDto((-pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);
    }
}


// PieceActor: knows about patterns for a single piece and can expand them into candidates
// Note: PieceActor is cell-agnostic; callers must supply the from-row/from-col when requesting candidates.
public sealed class PieceActor
{
    private readonly IPiecePolicy _policy;
    private readonly FactionActor? _faction;

    public PieceActor(IPiecePolicy policy, FactionActor? faction = null)
    {
        _policy = policy;
        _faction = faction;
    }

    public IEnumerable<ActionCandidate> GetCandidates(int fromRow, int fromCol)
    {
        (int X, int Y) forward = (1, 1);
        if (_faction != null) forward = _faction.GetForwardAxis();

        foreach (PatternDto p in _policy.GetPatterns())
        {
            int dx = p.Vector.X * forward.X;
            int dy = p.Vector.Y * forward.Y;
            int x = fromCol;
            int y = fromRow;
            int steps = 0;

            // Pieces generate unconstrained candidates; board-level actor/policy will filter out-of-bounds
            // We cap iterations to a reasonable board size (8) to avoid runaway loops in domain-agnostic code.
            int maxSteps = 8;

            do
            {
                x += dx;
                y += dy;
                steps++;

                // Emit the candidate without checking board occupancy or bounds. Post-processing will apply capture semantics.
                yield return new ActionCandidate(fromRow, fromCol, y, x, p, steps, p.Jumps);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
    {
        yield return (pattern.Vector, pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
    }
}

// BoardActor: composes piece actors for every piece on the board and applies board-level filters
public sealed class BoardActor : IActor
{
    private readonly IEnumerable<CellActor> _cells;
    private readonly Func<int, int, bool> _isInside;
    private readonly Func<int, int, object?> _getPieceAt;
    private readonly IPolicy? _policy;

    public BoardActor(IEnumerable<CellActor> cells, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
    {
        _cells = cells;
        _isInside = isInside;
        _getPieceAt = getPieceAt;
        _policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        // Build the candidate stream using the fluent CandidateBuilder and
        // ensure per-cell processing (direction blocking) is preserved.
        return CandidateBuilder
            .FromCellActors(_cells, _isInside, _getPieceAt)
            .ApplyPolicy(_policy)
            .Build();
    }

}

// GameActor: composes board actors and applies game-level policy such as turn filtering
public sealed class GameActor : IActor
{
    public GameState State { private get; set; }
    public GamePolicy Policy { private get; set; }

    public GameActor(GameState state, GamePolicy policy)
    {
        State = state;
        Policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        throw new NotImplementedException();
    }
}

public class PlayerActor
{
}

public class GameState
{
    int TurCount { get; set; }
    private readonly BoardActor _board;
    private readonly PlayerActor[] _players;
    public GameState(BoardActor board, PlayerActor[] players)
    {
        _board = board;
        _players = players;
    }
}

public class GamePolicy
{
}