using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core;
// Domain-agnostic pattern DTO used by the core move query system
public record PatternDto((int X, int Y) Vector,
    MirrorBehavior Mirrors = MirrorBehavior.All,
    RepeatBehavior Repeats = RepeatBehavior.Repeatable,
    CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
    bool ForwardOnly = false,
    bool Jumps = false
);

[Flags]
public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

// A candidate move generated by the builder before final filtering
public sealed record MoveCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping)
{
}

// Object-oriented actors for move expansion and filtering. These are domain-agnostic
// and operate using delegates supplied for board interrogation and faction info.

// A minimal interface for any actor that can produce move candidates
public interface IMoveActor
{
    IEnumerable<MoveCandidate> GetCandidates();
}

// Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
public interface IPolicy
{
    IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates);
}

// Faction-level policy abstraction: used by FactionActor to provide faction-specific info
public interface IFactionPolicy
{
    // Returns the forward axis multiplier for the faction (1 or -1)
    int GetForwardAxis();
}

// Delegate-based faction policy
public sealed class DelegateFactionPolicy : IFactionPolicy
{
    private readonly Func<int> _getForwardAxis;
    public DelegateFactionPolicy(Func<int> getForwardAxis) => _getForwardAxis = getForwardAxis;
    public int GetForwardAxis() => _getForwardAxis();
}

// FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
public sealed class FactionActor
{
    private readonly IFactionPolicy _policy;
    public FactionActor(IFactionPolicy policy) => _policy = policy;
    public int GetForwardAxis() => _policy.GetForwardAxis();
}

// CellActor: domain-agnostic representation of a board cell (row/col)
// CellActor now implements IMoveActor and may hold an optional PieceActor to which it delegates move expansion
public sealed class CellActor : IMoveActor
{
    public int Row { get; }
    public int Col { get; }
    public PieceActor? Piece { get; set; }

    public CellActor(int row, int col)
    {
        Row = row;
        Col = col;
    }

    public IEnumerable<MoveCandidate> GetCandidates()
    {
        if (Piece == null) yield break;
        foreach (var cand in Piece.GetCandidates(Row, Col))
            yield return cand;
    }
}

// Helper: expand mirrored vectors for a PatternDto into concrete PatternDto instances
internal static class PatternHelpers
{
    public static IEnumerable<PatternDto> ExpandMirrors(PatternDto pattern)
    {
        yield return new PatternDto(pattern.Vector, MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return new PatternDto((-pattern.Vector.X, pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return new PatternDto((pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return new PatternDto((-pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);
    }
}

// Piece-level policy: responsible for supplying pattern DTOs for a piece
public interface IPiecePolicy
{
    IEnumerable<PatternDto> GetPatterns();
}

// Delegate-based piece policy
public sealed class DelegatePiecePolicy : IPiecePolicy
{
    private readonly Func<IEnumerable<PatternDto>> _getBasePatterns;
    public DelegatePiecePolicy(Func<IEnumerable<PatternDto>> getBasePatterns) => _getBasePatterns = getBasePatterns;

    public IEnumerable<PatternDto> GetPatterns()
    {
        // Expand mirrors behind the policy. Faction parameter is provided for policies
        // that need to filter or transform patterns by faction (not used here yet).
        foreach (var basePattern in _getBasePatterns())
        {
            foreach (var expanded in PatternHelpers.ExpandMirrors(basePattern))
            {
                yield return expanded;
            }
        }
    }
}

// Delegate-based simple policy implementation
public sealed class DelegatePolicy : IPolicy
{
    private readonly Func<MoveCandidate, bool> _filter;
    public DelegatePolicy(Func<MoveCandidate, bool> filter) => _filter = filter;
    public IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates) => candidates.Where(_filter);
}

// PieceActor: knows about patterns for a single piece and can expand them into candidates
// Note: PieceActor is cell-agnostic; callers must supply the from-row/from-col when requesting candidates.
public sealed class PieceActor
{
    private readonly IPiecePolicy _policy;
    private readonly FactionActor? _faction;

    public PieceActor(IPiecePolicy policy, FactionActor? faction = null)
    {
        _policy = policy;
        _faction = faction;
    }

    public IEnumerable<MoveCandidate> GetCandidates(int fromRow, int fromCol)
    {
        int forward = 1;
        if (_faction != null) forward = _faction.GetForwardAxis();

        foreach (var p in _policy.GetPatterns())
        {
            int dx = p.Vector.X;
            int dy = p.Vector.Y * forward;
            int x = fromCol;
            int y = fromRow;
            int steps = 0;

            // Pieces generate unconstrained candidates; board-level actor/policy will filter out-of-bounds
            // We cap iterations to a reasonable board size (8) to avoid runaway loops in domain-agnostic code.
            int maxSteps = 8;

            do
            {
                x += dx;
                y += dy;
                steps++;

                // Emit the candidate without checking board occupancy or bounds. Post-processing will apply capture semantics.
                yield return new MoveCandidate(fromRow, fromCol, y, x, p, steps, p.Jumps);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
    {
        yield return (pattern.Vector, pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
    }
}

// BoardActor: composes piece actors for every piece on the board and applies board-level filters
public sealed class BoardActor : IMoveActor
{
    private readonly IEnumerable<CellActor> _cells;
    private readonly Func<int, int, bool> _isInside;
    private readonly Func<int, int, object?> _getPieceAt;
    private readonly IPolicy? _policy;

    public BoardActor(IEnumerable<CellActor> cells, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
    {
        _cells = cells;
        _isInside = isInside;
        _getPieceAt = getPieceAt;
        _policy = policy;
    }

    public IEnumerable<MoveCandidate> GetCandidates()
    {
        // We must process each cell actor's stream and apply board-level checks such as bounds and occupancy.
        foreach (var cell in _cells)
        {
            MoveCandidate? previous = null;
            bool directionBlocked = false;

            foreach (var cand in cell.GetCandidates())
            {
                // If the pattern changed (or steps reset), start a new direction
                if (previous == null || !ReferenceEquals(previous.Pattern, cand.Pattern) || cand.Steps <= previous.Steps)
                {
                    directionBlocked = false;
                }

                previous = cand;

                if (directionBlocked) continue;

                // Check bounds
                if (!_isInside(cand.ToRow, cand.ToCol))
                {
                    // Once a direction goes out of bounds, further steps in this direction are irrelevant
                    directionBlocked = true;
                    continue;
                }

                var occupying = _getPieceAt(cand.ToRow, cand.ToCol);

                // If square is empty, yield candidate. If occupied, yield candidate and block further steps in this direction.
                if (occupying == null)
                {
                    yield return cand;
                }
                else
                {
                    yield return cand;
                    directionBlocked = true;
                }
            }
        }
    }
}

// GameActor: composes board actors and applies game-level policy such as turn filtering
public sealed class GameActor : IMoveActor
{
    private readonly BoardActor _boardActor;
    private readonly IPolicy? _policy;

    public GameActor(BoardActor boardActor, IPolicy? policy = null)
    {
        _boardActor = boardActor;
        _policy = policy;
    }

    public IEnumerable<MoveCandidate> GetCandidates()
    {
        var all = _boardActor.GetCandidates();
        if (_policy != null) return _policy.Apply(all);
        return all;
    }
}

