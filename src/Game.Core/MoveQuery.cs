using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core
{
    // Domain-agnostic pattern DTO used by the core move query system
    public record PatternDto((int X, int Y) Vector,
        MirrorBehavior Mirrors = MirrorBehavior.All,
        RepeatBehavior Repeats = RepeatBehavior.Repeatable,
        CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
        bool ForwardOnly = false,
        bool Jumps = false
    );

    [Flags]
    public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
    public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
    public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

    // A candidate move generated by the builder before final filtering
    public sealed record MoveCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping)
    {
    }

    // Object-oriented actors for move expansion and filtering. These are domain-agnostic
    // and operate using delegates supplied for board interrogation and faction info.

    // A minimal interface for any actor that can produce move candidates
    public interface IMoveActor
    {
        IEnumerable<MoveCandidate> GetCandidates();
    }

    // Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
    public interface IPolicy
    {
        IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates);
    }

    // Faction-level policy abstraction: used by FactionActor to provide faction-specific info
    public interface IFactionPolicy
    {
        // Returns the forward axis multiplier for the faction (1 or -1)
        int GetForwardAxis();
    }

    // Delegate-based faction policy
    public sealed class DelegateFactionPolicy : IFactionPolicy
    {
        private readonly Func<int> _getForwardAxis;
        public DelegateFactionPolicy(Func<int> getForwardAxis) => _getForwardAxis = getForwardAxis;
        public int GetForwardAxis() => _getForwardAxis();
    }

    // FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
    public sealed class FactionActor
    {
        private readonly IFactionPolicy _policy;
        public FactionActor(IFactionPolicy policy) => _policy = policy;
        public int GetForwardAxis() => _policy.GetForwardAxis();
    }

    // CellActor: domain-agnostic representation of a board cell (row/col)
    public sealed class CellActor
    {
        public int Row { get; }
        public int Col { get; }
        public CellActor(int row, int col)
        {
            Row = row;
            Col = col;
        }
    }

    // Piece-level policy: responsible for supplying pattern DTOs for a piece
    public interface IPiecePolicy
    {
        IEnumerable<PatternDto> GetPatterns();
    }

    // Delegate-based piece policy
    public sealed class DelegatePiecePolicy : IPiecePolicy
    {
        private readonly Func<IEnumerable<PatternDto>> _getPatterns;
        public DelegatePiecePolicy(Func<IEnumerable<PatternDto>> getPatterns) => _getPatterns = getPatterns;
        public IEnumerable<PatternDto> GetPatterns() => _getPatterns();
    }

    // Delegate-based simple policy implementation
    public sealed class DelegatePolicy : IPolicy
    {
        private readonly Func<MoveCandidate, bool> _filter;
        public DelegatePolicy(Func<MoveCandidate, bool> filter) => _filter = filter;
        public IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates) => candidates.Where(_filter);
    }

    // PieceActor: knows about patterns for a single piece and can expand them into candidates
    public sealed class PieceActor : IMoveActor
    {
        private readonly IPiecePolicy _policy;
        private readonly CellActor _cell;
        private readonly FactionActor _faction;

        public PieceActor(IPiecePolicy policy, CellActor cell, FactionActor faction)
        {
            _policy = policy;
            _cell = cell;
            _faction = faction;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            int forward = _faction.GetForwardAxis();

            foreach (var p in _policy.GetPatterns())
            {
                foreach (var dir in GetMirroredVectors(p))
                {
                    int dx = dir.Vector.X;
                    int dy = dir.Vector.Y * forward;
                    int x = _cell.Col;
                    int y = _cell.Row;
                    int steps = 0;

                    // Pieces generate unconstrained candidates; board-level actor/policy will filter out-of-bounds
                    // We cap iterations to a reasonable board size (8) to avoid runaway loops in domain-agnostic code.
                    int maxSteps = 8;

                    do
                    {
                        x += dx;
                        y += dy;
                        steps++;

                        // Emit the candidate without checking board occupancy or bounds. Post-processing will apply capture semantics.
                        yield return new MoveCandidate(_cell.Row, _cell.Col, y, x, p, steps, p.Jumps);

                        if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                            break;

                        if (steps >= maxSteps) break;

                    } while (true);
                }
            }
        }

        private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
        {
            yield return (pattern.Vector, pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
                yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
                yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
                yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
        }
    }

    // BoardActor: composes piece actors for every piece on the board and applies board-level filters
    public sealed class BoardActor : IMoveActor
    {
        private readonly IEnumerable<PieceActor> _pieceActors;
        private readonly Func<int, int, bool> _isInside;
        private readonly Func<int, int, object?> _getPieceAt;
        private readonly IPolicy? _policy;

        public BoardActor(IEnumerable<PieceActor> pieceActors, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
        {
            _pieceActors = pieceActors;
            _isInside = isInside;
            _getPieceAt = getPieceAt;
            _policy = policy;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            // We must process each piece actor's stream and apply board-level checks such as bounds and occupancy.
            foreach (var pa in _pieceActors)
            {
                MoveCandidate? previous = null;
                bool directionBlocked = false;

                foreach (var cand in pa.GetCandidates())
                {
                    // If the pattern changed (or steps reset), start a new direction
                    if (previous == null || !ReferenceEquals(previous.Pattern, cand.Pattern) || cand.Steps <= previous.Steps)
                    {
                        directionBlocked = false;
                    }

                    previous = cand;

                    if (directionBlocked) continue;

                    // Check bounds
                    if (!_isInside(cand.ToRow, cand.ToCol))
                    {
                        // Once a direction goes out of bounds, further steps in this direction are irrelevant
                        directionBlocked = true;
                        continue;
                    }

                    var occupying = _getPieceAt(cand.ToRow, cand.ToCol);

                    // If square is empty, yield candidate. If occupied, yield candidate and block further steps in this direction.
                    if (occupying == null)
                    {
                        yield return cand;
                    }
                    else
                    {
                        yield return cand;
                        directionBlocked = true;
                    }
                }
            }

            // Apply an optional board-level policy afterwards
            // Note: we return an iterator, so to apply policy we must materialize the sequence first
            // If policy is present, apply it to the collected candidates
            // (Materialization is intentional; consumers expect a finite list)
            // However, for performance we only apply policy if provided.
            // To keep streaming behaviour, policy application could be implemented differently if needed.

            // Since we've already yielded candidates directly above, we cannot reapply policy here.
            // Instead the caller may wrap BoardActor with a DelegatePolicy if further filtering is required.
        }
    }

    // GameActor: composes board actors and applies game-level policy such as turn filtering
    public sealed class GameActor : IMoveActor
    {
        private readonly BoardActor _boardActor;
        private readonly IPolicy? _policy;

        public GameActor(BoardActor boardActor, IPolicy? policy = null)
        {
            _boardActor = boardActor;
            _policy = policy;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            var all = _boardActor.GetCandidates();
            if (_policy != null) return _policy.Apply(all);
            return all;
        }
    }

}
