using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core
{
    // Domain-agnostic pattern DTO used by the core move query system
    public record PatternDto((int X, int Y) Vector,
        MirrorBehavior Mirrors = MirrorBehavior.All,
        RepeatBehavior Repeats = RepeatBehavior.Repeatable,
        CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
        bool ForwardOnly = false,
        bool Jumps = false
    );

    [Flags]
    public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
    public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
    public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

    // A candidate move generated by the builder before final filtering
    public sealed record MoveCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping)
    {
    }

    // Object-oriented actors for move expansion and filtering. These are domain-agnostic
    // and operate using delegates supplied for board interrogation and faction info.

    // A minimal interface for any actor that can produce move candidates
    public interface IMoveActor
    {
        IEnumerable<MoveCandidate> GetCandidates();
    }

    // Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
    public interface IPolicy
    {
        IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates);
    }

    // Faction-level policy abstraction: used by FactionActor to provide faction-specific info
    public interface IFactionPolicy
    {
        // Returns the forward axis multiplier for the faction (1 or -1)
        int GetForwardAxis();
    }

    // Delegate-based faction policy
    public sealed class DelegateFactionPolicy : IFactionPolicy
    {
        private readonly Func<int> _getForwardAxis;
        public DelegateFactionPolicy(Func<int> getForwardAxis) => _getForwardAxis = getForwardAxis;
        public int GetForwardAxis() => _getForwardAxis();
    }

    // FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
    public sealed class FactionActor
    {
        private readonly IFactionPolicy _policy;
        public FactionActor(IFactionPolicy policy) => _policy = policy;
        public int GetForwardAxis() => _policy.GetForwardAxis();
    }

    // Delegate-based simple policy implementation
    public sealed class DelegatePolicy : IPolicy
    {
        private readonly Func<MoveCandidate, bool> _filter;
        public DelegatePolicy(Func<MoveCandidate, bool> filter) => _filter = filter;
        public IEnumerable<MoveCandidate> Apply(IEnumerable<MoveCandidate> candidates) => candidates.Where(_filter);
    }

    // PieceActor: knows about patterns for a single piece and can expand them into candidates
    public sealed class PieceActor : IMoveActor
    {
        private readonly int _fromRow;
        private readonly int _fromCol;
        private readonly IEnumerable<PatternDto> _patterns;
        private readonly FactionActor? _factionActor;
        private readonly Func<int, int, bool> _isInside;
        private readonly Func<int, int, object?> _getPieceAt;
        private readonly bool _forceIncludeCaptures;
        private readonly bool _forceExcludeMoves;

        public PieceActor(int fromRow, int fromCol, IEnumerable<PatternDto> patterns,
            Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt,
            FactionActor? factionActor = null, bool forceIncludeCaptures = false, bool forceExcludeMoves = false)
        {
            _fromRow = fromRow;
            _fromCol = fromCol;
            _patterns = patterns;
            _factionActor = factionActor;
            _isInside = isInside;
            _getPieceAt = getPieceAt;
            _forceIncludeCaptures = forceIncludeCaptures;
            _forceExcludeMoves = forceExcludeMoves;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            int forward = 1;
            if (_factionActor != null) forward = _factionActor.GetForwardAxis();

            foreach (var p in _patterns)
            {
                foreach (var dir in GetMirroredVectors(p))
                {
                    int dx = dir.Vector.X;
                    int dy = dir.Vector.Y * forward;
                    int x = _fromCol;
                    int y = _fromRow;
                    int steps = 0;

                    do
                    {
                        x += dx;
                        y += dy;
                        steps++;

                        if (!_isInside(y, x)) break;

                        var pieceTo = _getPieceAt(y, x);

                        if (pieceTo == null)
                        {
                            if (p.Captures == CaptureBehavior.MoveOnly || p.Captures == CaptureBehavior.MoveOrCapture)
                            {
                                if (!_forceExcludeMoves)
                                {
                                    yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                                }
                            }
                            if (_forceIncludeCaptures)
                            {
                                if (p.Captures == CaptureBehavior.CaptureOnly || p.Captures == CaptureBehavior.MoveOrCapture)
                                {
                                    yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                                }
                            }
                        }
                        else
                        {
                            // let caller decide capture semantics in a post-process using the pattern metadata
                            yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                            break;
                        }

                        if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                            break;

                    } while (true);
                }
            }
        }

        private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
        {
            yield return (pattern.Vector, pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
                yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
                yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
                yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
        }
    }

    // BoardActor: composes piece actors for every piece on the board and applies board-level filters
    public sealed class BoardActor : IMoveActor
    {
        private readonly IEnumerable<PieceActor> _pieceActors;
        private readonly IPolicy? _policy;

        public BoardActor(IEnumerable<PieceActor> pieceActors, IPolicy? policy = null)
        {
            _pieceActors = pieceActors;
            _policy = policy;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            var all = _pieceActors.SelectMany(pa => pa.GetCandidates());
            if (_policy != null) return _policy.Apply(all);
            return all;
        }
    }

    // GameActor: composes board actors and applies game-level policy such as turn filtering
    public sealed class GameActor : IMoveActor
    {
        private readonly BoardActor _boardActor;
        private readonly IPolicy? _policy;

        public GameActor(BoardActor boardActor, IPolicy? policy = null)
        {
            _boardActor = boardActor;
            _policy = policy;
        }

        public IEnumerable<MoveCandidate> GetCandidates()
        {
            var all = _boardActor.GetCandidates();
            if (_policy != null) return _policy.Apply(all);
            return all;
        }
    }

}
