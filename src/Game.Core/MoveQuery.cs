// using System;
// using System.Collections.Generic;
// using System.Linq;

// namespace Game.Core.Wip;
// // Domain-agnostic pattern DTO used by the core move query system
// public record PatternDto((int X, int Y) Vector,
//     MirrorBehavior Mirrors = MirrorBehavior.All,
//     RepeatBehavior Repeats = RepeatBehavior.Repeatable,
//     CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
//     bool ForwardOnly = false,
//     bool Jumps = false
// );

// [Flags]
// public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
// public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
// public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

// // A candidate move generated by the builder before final filtering
// public sealed record ActionCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping, List<CellActor> TraversedCells, Piece? Piece = null)
// {
// }

// // Object-oriented actors for move expansion and filtering. These are domain-agnostic
// // and operate using delegates supplied for board interrogation and faction info.

// // A minimal interface for any actor that can produce move candidates
// public interface IActor
// {
//     IEnumerable<ActionCandidate> GetActionCandidates();
// }

// // Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
// public interface IPolicy
// {
//     IEnumerable<ActionCandidate> Apply(IEnumerable<ActionCandidate> candidates);
// }

// // Concrete faction policy
// public sealed class FactionPolicy
// {
//     private readonly (int X, int Y) _forward;
//     public FactionPolicy((int X, int Y) forward) => _forward = forward;
//     public (int X, int Y) GetForwardAxis() => _forward;
// }

// // FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
// public sealed class FactionActor
// {
//     public FactionPolicy Policy { private set; get; }
//     public FactionActor(FactionPolicy policy) => Policy = policy;
// }

// // CellActor: domain-agnostic representation of a board cell (row/col)
// // CellActor now implements IMoveActor and may hold an optional PieceActor to which it delegates move expansion
// public sealed class CellActor : IActor
// {
//     public int Row { get; }
//     public int Col { get; }
//     public PieceActor? OccupyingPiece { get; set; }

//     public CellActor(int row, int col)
//     {
//         Row = row;
//         Col = col;
//     }

//     public IEnumerable<ActionCandidate> GetActionCandidates()
//     {
//         if (OccupyingPiece == null) yield break;
//         foreach (ActionCandidate cand in OccupyingPiece.GetCandidates(Row, Col))
//             yield return cand;
//     }
// }



// // Concrete piece policy
// public sealed class PiecePolicy
// {
//     private readonly IEnumerable<PatternDto> _basePatterns;
//     public PiecePolicy(IEnumerable<PatternDto> basePatterns) => _basePatterns = basePatterns;

//     public IEnumerable<PatternDto> GetPatterns()
//     {
//         foreach (PatternDto basePattern in _basePatterns)
//         {
//             foreach (PatternDto mirroredPattern in GetMirroredPatterns(basePattern))
//             {
//                 yield return mirroredPattern;
//             }
//         }
//     }

//     private static IEnumerable<PatternDto> GetMirroredPatterns(PatternDto pattern)
//     {
//         yield return new PatternDto(pattern.Vector, MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
//             yield return new PatternDto((-pattern.Vector.X, pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
//             yield return new PatternDto((pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
//             yield return new PatternDto((-pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);
//     }
// }


// public sealed class PieceActor
// {
//     private readonly PiecePolicy _policy;
//     private readonly FactionActor _faction;

//     public PieceActor(PiecePolicy policy, FactionActor faction)
//     {
//         _policy = policy;
//         _faction = faction;
//     }

//     //TODO: refactor to expand pattern deltas instead (without adding the starting position)
//     // also, turn into arguments: the forward axis and the patterns collection
//     public IEnumerable<ActionCandidate> GetCandidates(int fromRow, int fromCol)
//     {
//         (int X, int Y) forward = (1, 1);
//         if (_faction != null) forward = _faction.Policy.GetForwardAxis();

//         foreach (PatternDto p in _policy.GetPatterns())
//         {
//             int dx = p.Vector.X * forward.X;
//             int dy = p.Vector.Y * forward.Y;
//             int x = fromCol;
//             int y = fromRow;
//             int steps = 0;
//             int maxSteps = 8;

//             var traversedCells = new List<CellActor>();
//             do
//             {
//                 x += dx;
//                 y += dy;
//                 steps++;

//                 var cell = new CellActor(y, x);
//                 traversedCells.Add(cell);
//                 var traversedCellsClone = new List<CellActor>(traversedCells);

//                 yield return new ActionCandidate(fromRow, fromCol, y, x, p, steps, p.Jumps, traversedCellsClone);

//                 if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
//                     break;

//                 if (steps >= maxSteps) break;

//             } while (true);
//         }
//     }

//     private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
//     {
//         yield return (pattern.Vector, pattern.Mirrors);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
//             yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
//             yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

//         if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
//             yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
//     }
// }

// // BoardActor: composes piece actors for every piece on the board and applies board-level filters
// public sealed class BoardActor : IActor
// {
//     private readonly IEnumerable<CellActor> _cells;
//     private readonly Func<int, int, bool> _isInside;
//     private readonly Func<int, int, object?> _getPieceAt;
//     private readonly IPolicy? _policy;

//     public BoardActor(IEnumerable<CellActor> cells, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
//     {
//         _cells = cells;
//         _isInside = isInside;
//         _getPieceAt = getPieceAt;
//         _policy = policy;
//     }

//     public IEnumerable<ActionCandidate> GetActionCandidates()
//     {
//         return CandidateBuilder
//             .FromCellActors(_cells, _isInside, _getPieceAt)
//             .ApplyPolicy(_policy)
//             .Build();
//     }

// }

// public sealed class GameActor : IActor
// {
//     public GameState State { private get; set; }
//     public GamePolicy Policy { private get; set; }

//     public GameActor(GameState state, GamePolicy policy)
//     {
//         State = state;
//         Policy = policy;
//     }

//     public IEnumerable<ActionCandidate> GetActionCandidates()
//     {
//         throw new NotImplementedException();
//     }
// }

// public class PlayerActor
// {
// }

// public class GameState
// {
//     int TurCount { get; set; }
//     private readonly BoardActor _board;
//     private readonly PlayerActor[] _players;
//     public GameState(BoardActor board, PlayerActor[] players)
//     {
//         _board = board;
//         _players = players;
//     }
// }

// public class GamePolicy
// {
// }

// // New core-level types implementing the Game -> Board -> Piece flow
// public enum Faction { White, Black }

// public sealed class Piece
// {
//     public int Row { get; private set; }
//     public int Col { get; private set; }
//     public PiecePolicy Policy { get; }
//     public Faction Faction { get; }

//     public Piece(PiecePolicy policy, Faction faction, int row, int col)
//     {
//         Policy = policy;
//         Faction = faction;
//         Row = row;
//         Col = col;
//     }

//     public IEnumerable<ActionCandidate> GetActions(int rows, int cols)
//     {
//         // Determine forward axis based on faction: white moves +Y, black moves -Y
//         (int X, int Y) forward = Faction == Faction.White ? (1, 1) : (1, -1);

//         // Note: using existing pattern expansion from PiecePolicy
//         foreach (PatternDto p in Policy.GetPatterns())
//         {
//             int dx = p.Vector.X * forward.X;
//             int dy = p.Vector.Y * forward.Y;
//             int x = Col;
//             int y = Row;
//             int steps = 0;
//             int maxSteps = Math.Max(rows, cols);

//             var traversedCells = new List<CellActor>();
//             do
//             {
//                 x += dx;
//                 y += dy;
//                 steps++;

//                 var cell = new CellActor(y, x);
//                 traversedCells.Add(cell);
//                 var traversedCellsClone = new List<CellActor>(traversedCells);

//                 yield return new ActionCandidate(Row, Col, y, x, p, steps, p.Jumps, traversedCellsClone, this);

//                 if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
//                     break;

//                 if (steps >= maxSteps) break;

//             } while (true);
//         }
//     }

//     public void MoveTo(int newRow, int newCol)
//     {
//         Row = newRow;
//         Col = newCol;
//     }
// }

// public sealed class Board
// {
//     private readonly List<Piece> _pieces = new();
//     public int Rows { get; }
//     public int Cols { get; }

//     public Board(int rows, int cols)
//     {
//         Rows = rows;
//         Cols = cols;
//     }

//     public void Reset()
//     {
//         _pieces.Clear();
//     }

//     public void AddPiece(Piece p) => _pieces.Add(p);

//     public Piece? PieceAt(int row, int col) => _pieces.FirstOrDefault(p => p.Row == row && p.Col == col);

//     public void Apply(ActionCandidate action)
//     {
//         Piece? p = action.Piece ?? PieceAt(action.FromRow, action.FromCol);
//         if (p == null) return;
//         p.MoveTo(action.ToRow, action.ToCol);
//     }

//     // public IEnumerable<ActionCandidate> GetActionsLinq()
//     // {
//     //     const int maxExplodeSteps = 8;

//     //     int PieceId(int row, int col) => HashCode.Combine(row, col);
//     //     int DirectionId(PatternDto d) => HashCode.Combine(d.Vector.X, d.Vector.Y, d.Captures);

//     //     // 1️⃣ Generate all exploded move targets (piece × direction × step)
//     //     var exploded =
//     //         from Piece p in _pieces
//     //         from PatternDto d in p.Policy.GetPatterns()
//     //         from int step in Enumerable.Range(1, maxExplodeSteps)
//     //         let toRow = p.Row + d.Vector.X * step
//     //         let toCol = p.Col + d.Vector.Y * step
//     //         select new
//     //         {
//     //             Piece = p,
//     //             Direction = d,
//     //             Step = step,
//     //             ToRow = toRow,
//     //             ToCol = toCol,
//     //             Occupying = PieceAt(toRow, toCol)
//     //         };

//     //     // 2️⃣ Keep only cells inside the board
//     //     var bounded =
//     //         from e in exploded
//     //         select e;

//     //     // 3️⃣ Compute, per (piece,direction), where the *first occupied* cell is
//     //     var firstBlocks =
//     //         from e in bounded
//     //         where e.Occupying != null
//     //         group e by new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } into g
//     //         select new
//     //         {
//     //             g.Key.Id,
//     //             g.Key.Id1,
//     //             FirstBlockStep = g.Min(x => x.Step)
//     //         };

//     //     // 4️⃣ Join exploded moves with the first-block info
//     //     var joined =
//     //         from e in bounded
//     //         join fb in firstBlocks
//     //             on new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } equals new { fb.Id, fb.Id1 }
//     //             into fbGroup
//     //         from fb in fbGroup.DefaultIfEmpty()
//     //         select new
//     //         {
//     //             e,
//     //             FirstBlockStep = fb?.FirstBlockStep
//     //         };

//     //     // 5️⃣ Filter to keep only steps before the first occupied
//     //     var visible =
//     //         from j in joined
//     //         where j.FirstBlockStep == null || j.e.Step <= j.FirstBlockStep
//     //         select j.e;

//     //     // 6️⃣ Convert to ActionCandidates and filter final legality
//     //     var legal =
//     //         from v in visible
//     //         where IsValidTarget(v.ToRow, v.ToCol, v.Direction.Captures)
//     //            && IsValidMovePath(v.ToRow, v.ToCol, v.Direction.Captures)
//     //         select new ActionCandidate(
//     //             v.Piece.Row,
//     //             v.Piece.Col,
//     //             v.ToRow,
//     //             v.ToCol,
//     //             v.Direction,
//     //             v.Step,

//     //             v.Direction.Jumps,
//     //             new List<CellActor>()
//     //         );

//     //     return legal;
//     // }

//     // Variant that allows injecting a captures/jumps filter to help diagnose which
//     // of those two attributes causes a candidate to be rejected.
//     public IEnumerable<ActionCandidate> GetActionsLinq(Faction turnFaction, CaptureBehavior capturesFilter, bool jumpsFilter)
//     {
//         const int maxExplodeSteps = 8;

//         int PieceId(int row, int col) => HashCode.Combine(row, col);
//         int DirectionId(PatternDto d) => HashCode.Combine(d.Vector.X, d.Vector.Y, d.Captures);

//         // 1️⃣ Generate all exploded move targets (piece × direction × step)
//         var exploded =
//             from Piece p in _pieces.Filter(p => p.Faction == turnFaction)
//             from PatternDto d in p.Policy.GetPatterns().Filter(d => d.Captures == capturesFilter && d.Jumps == jumpsFilter)
//             from int step in Enumerable.Range(1, d.Jumps ? 1 : maxExplodeSteps)
//             let toRow = p.Row + d.Vector.X * step
//             let toCol = p.Col + d.Vector.Y * step
//             select new
//             {
//                 Piece = p,
//                 Direction = d,
//                 Step = step,
//                 ToRow = toRow,
//                 ToCol = toCol,
//                 Occupying = PieceAt(toRow, toCol)
//             };

//         // 2️⃣ Keep only cells inside the board
//         var bounded =
//             from e in exploded
//             select e;

//         // 3️⃣ Compute, per (piece,direction), where the *first occupied* cell is
//         var firstBlocks =
//             from e in bounded
//             where e.Occupying != null
//             group e by new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } into g
//             select new
//             {
//                 g.Key.Id,
//                 g.Key.Id1,
//                 FirstBlockStep = g.Min(x => x.Step)
//             };

//         // 4️⃣ Join exploded moves with the first-block info
//         var joined =
//             from e in bounded
//             join fb in firstBlocks
//                 on new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } equals new { fb.Id, fb.Id1 }
//                 into fbGroup
//             from fb in fbGroup.DefaultIfEmpty()
//             select new
//             {
//                 e,
//                 FirstBlockStep = fb?.FirstBlockStep
//             };

//         // 5️⃣ Filter to keep only steps before the first occupied
//         var visible =
//             from j in joined
//             where j.FirstBlockStep == null || j.e.Step <= j.FirstBlockStep
//             select j.e;

//         // 6️⃣ Convert to ActionCandidates and filter final legality using the provided filters
//         var legal =
//             from v in visible
//             where v.Direction.Captures == capturesFilter
//                && v.Direction.Jumps == jumpsFilter
//                && IsValidTarget(v.ToRow, v.ToCol, capturesFilter)
//                && IsValidMovePath(v.ToRow, v.ToCol, capturesFilter)
//             select new ActionCandidate(
//                 v.Piece.Row,
//                 v.Piece.Col,
//                 v.ToRow,
//                 v.ToCol,
//                 v.Direction,
//                 v.Step,

//                 v.Direction.Jumps,
//                 new List<CellActor>()
//             );

//         return legal;
//     }

//     public IEnumerable<ActionCandidate> GetActions(Faction turnFaction)
//     {
//         // Extract per-piece expansion to a helper for clarity and incremental refactor.
//         const int maxExplodeSteps = 8;

//         IEnumerable<ActionCandidate> ExpandPieceActions(Piece p)
//         {
//             var results = new List<ActionCandidate>();

//             // Determine forward axis based on faction: white moves +Y, black moves -Y
//             (int X, int Y) forward = p.Faction == Faction.White ? (1, 1) : (1, -1);

//             foreach (PatternDto pattern in p.Policy.GetPatterns())
//             {
//                 int dx = pattern.Vector.X * forward.X;
//                 int dy = pattern.Vector.Y * forward.Y;
//                 int x = p.Col;
//                 int y = p.Row;
//                 int steps = 0;

//                 var traversedCells = new List<CellActor>();

//                 while (true)
//                 {
//                     x += dx;
//                     y += dy;
//                     steps++;

//                     // Cap expansion per-direction to maxExplodeSteps
//                     if (steps > maxExplodeSteps)
//                         break;


//                     var cell = new CellActor(y, x);
//                     traversedCells.Add(cell);
//                     var traversedClone = new List<CellActor>(traversedCells);

//                     var occupying = PieceAt(y, x);

//                     var cand = new ActionCandidate(p.Row, p.Col, y, x, pattern, steps, pattern.Jumps, traversedClone, p);
//                     results.Add(cand);

//                     // If occupied, stop further steps in this direction
//                     if (occupying != null)
//                         break;

//                     if (pattern.Repeats == RepeatBehavior.NotRepeatable || (pattern.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || pattern.Jumps)
//                         break;
//                 }
//             }

//             return results;
//         }

//         IEnumerable<ActionCandidate> expanded = _pieces
//             // parallelize the piece-level work to distribute expansion across cores
//             .AsParallel()
//             // keep ordering predictable; remove AsOrdered() if you don't need determinism
//             .AsOrdered()
//             .SelectMany(p => ExpandPieceActions(p))
//             .AsSequential();

//         var r = expanded
//             .Filter(a => IsInside(a.FromRow, a.FromCol))
//             .Filter(a => IsInside(a.ToRow, a.ToCol))
//             .Filter(a => IsValidTarget(a.ToRow, a.ToCol, a.Pattern.Captures))
//             .Filter(a => a.TraversedCells.All(cell => IsValidMovePath(cell.Row, cell.Col, a.Pattern.Captures)));

//         var jumps = r.Filter(a => a.Pattern.Captures == CaptureBehavior.MoveOrCapture && a.Pattern.Jumps);

//         var jumpsLinq = GetActionsLinq(turnFaction, CaptureBehavior.MoveOrCapture, true)
//             .Filter(a => IsInside(a.FromRow, a.FromCol))
//             .Filter(a => IsInside(a.ToRow, a.ToCol));

//         //compare the three sets for debugging/discrepancies here using the difference in count
//         var jumpsDiff = jumps.Count() - jumpsLinq.Count();

//         // Console.WriteLine($"Jumps Diff Len: {jumpsDiff}(Jumps: {jumps.Count()} vs {jumpsLinq.Count()})");

//         // // if jump counts differ, check which specific candidates are missing/extra
//         // if (jumpsDiff != 0)
//         // {
//         //     var jumpsSet = new HashSet<(int FromRow, int FromCol, int ToRow, int ToCol)>(jumps.Select(a => (a.FromRow, a.FromCol, a.ToRow, a.ToCol)));
//         //     var jumpsLinqSet = new HashSet<(int FromRow, int FromCol, int ToRow, int ToCol)>(jumpsLinq.Select(a => (a.FromRow, a.FromCol, a.ToRow, a.ToCol)));

//         //     var missingInLinq = jumpsSet.Except(jumpsLinqSet).ToList();
//         //     var extraInLinq = jumpsLinqSet.Except(jumpsSet).ToList();

//         //     Console.WriteLine("Missing in LINQ:");
//         //     foreach (var item in missingInLinq)
//         //     {
//         //         Console.WriteLine(item);
//         //     }

//         //     Console.WriteLine("Extra in LINQ:");
//         //     foreach (var item in extraInLinq)
//         //     {
//         //         Console.WriteLine(item);
//         //     }
//         // }


//         return r;
//     }

//     public bool IsInside(int row, int col) => row >= 0 && row < Rows && col >= 0 && col < Cols;

//     public bool IsValidTarget(int row, int col, CaptureBehavior captures)
//     {
//         Piece? target = PieceAt(row, col);
//         bool isOccupied = target != null;

//         return captures switch
//         {
//             CaptureBehavior.MoveOnly => !isOccupied,
//             CaptureBehavior.CaptureOnly => isOccupied,
//             CaptureBehavior.MoveOrCapture => true,
//             _ => false,
//         };
//     }
//     public bool IsValidMovePath(int row, int col, CaptureBehavior captures)
//     {
//         if (captures == CaptureBehavior.MoveOnly)
//         {
//             Piece? target = PieceAt(row, col);
//             bool isOccupied = target != null;
//             return !isOccupied;
//         }
//         return true;
//     }
// }

// public sealed class Game
// {
//     private readonly Board _board;
//     public int TurnCount { get; private set; }
//     public Faction TurnFaction { get; private set; }

//     public Game(Board board)
//     {
//         _board = board;
//         Reset();
//     }

//     public void Reset()
//     {
//         TurnCount = 0;
//         TurnFaction = Faction.White;
//         _board.Reset();
//     }

//     public void Apply(ActionCandidate action) => _board.Apply(action);

//     public IEnumerable<ActionCandidate> GetActions()
//     {
//         return _board.GetActions(TurnFaction)
//                      .Filter(a => a.Piece != null && a.Piece.Faction == TurnFaction)
//                      .Filter(a => !IsBlocked(a))
//                      .Filter(a => true) // placeholder for empty captures
//                      .Filter(a => true) // placeholder for checking moves
//                      .Explode(a => new[] { a }); // placeholder for castle explosion
//     }

//     private bool IsBlocked(ActionCandidate a)
//     {
//         var dest = _board.PieceAt(a.ToRow, a.ToCol);
//         return dest != null && a.Piece != null && dest.Faction == a.Piece.Faction;
//     }

// }

// public static class MoveExtensions
// {
//     public static IEnumerable<T> Filter<T>(this IEnumerable<T> source, Func<T, bool> predicate)
//         => source.Where(predicate);

//     public static IEnumerable<T> Explode<T>(this IEnumerable<T> source, Func<T, IEnumerable<T>> generator)
//         => source.SelectMany(generator);
// }