using System;
using System.Collections.Generic;

namespace Game.Core
{
    // Domain-agnostic pattern DTO used by the core move query system
    public record PatternDto((int X, int Y) Vector,
        MirrorBehavior Mirrors = MirrorBehavior.All,
        RepeatBehavior Repeats = RepeatBehavior.Repeatable,
        CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
        bool ForwardOnly = false,
        bool Jumps = false
    );

    [Flags]
    public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
    public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
    public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

    // A candidate move generated by the builder before final filtering
    public sealed record MoveCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping)
    {
    }

    // A SQL-like fluent builder that expands pattern DTOs into MoveCandidates
    // It is domain-agnostic: caller supplies IsInside, GetPieceAt and ForwardAxis functions.
    public class MoveQueryBuilder
    {
        private readonly List<PatternDto> _patterns = new();
        private int _fromRow;
        private int _fromCol;
        private Func<int>? _forwardAxisGetter;

        public MoveQueryBuilder From(int row, int col)
        {
            _fromRow = row;
            _fromCol = col;
            return this;
        }

        public MoveQueryBuilder WithPatterns(IEnumerable<PatternDto> patterns)
        {
            _patterns.AddRange(patterns);
            return this;
        }

        // optional override to determine forward direction multiplier (1 or -1)
        public MoveQueryBuilder WithForwardAxis(Func<int> forwardAxisGetter)
        {
            _forwardAxisGetter = forwardAxisGetter;
            return this;
        }

        // Expand into candidates using provided board query delegates
        public IEnumerable<MoveCandidate> Execute(Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, Func<int>? forwardAxis = null, bool forceIncludeCaptures = false, bool forceExcludeMoves = false)
        {
            int forward = 1;
            if (_forwardAxisGetter != null) forward = _forwardAxisGetter();
            else if (forwardAxis != null) forward = forwardAxis();

            foreach (var p in _patterns)
            {
                foreach (var dir in GetMirroredVectors(p))
                {
                    int dx = dir.Vector.X;
                    int dy = dir.Vector.Y * forward;
                    int x = _fromCol;
                    int y = _fromRow;
                    int steps = 0;

                    do
                    {
                        x += dx;
                        y += dy;
                        steps++;

                        if (!isInside(y, x)) break;

                        var pieceTo = getPieceAt(y, x);

                        if (pieceTo == null)
                        {
                            if (p.Captures == CaptureBehavior.MoveOnly || p.Captures == CaptureBehavior.MoveOrCapture)
                            {
                                if (!forceExcludeMoves)
                                {
                                    yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                                }
                            }
                            if (forceIncludeCaptures)
                            {
                                if (p.Captures == CaptureBehavior.CaptureOnly || p.Captures == CaptureBehavior.MoveOrCapture)
                                {
                                    yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                                }
                            }
                        }
                        else
                        {
                            // let caller decide capture semantics in a post-process using the pattern metadata
                            yield return new MoveCandidate(_fromRow, _fromCol, y, x, p, steps, p.Jumps);
                            break;
                        }

                        if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                            break;

                    } while (true);
                }
            }
        }

        private static IEnumerable<( (int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
        {
            yield return (pattern.Vector, pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
                yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
                yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

            if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
                yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
        }
    }
}
