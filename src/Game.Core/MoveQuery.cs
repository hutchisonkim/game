using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core.Wip;
// Domain-agnostic pattern DTO used by the core move query system
public record PatternDto((int X, int Y) Vector,
    MirrorBehavior Mirrors = MirrorBehavior.All,
    RepeatBehavior Repeats = RepeatBehavior.Repeatable,
    CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
    bool ForwardOnly = false,
    bool Jumps = false
);

[Flags]
public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

// A candidate move generated by the builder before final filtering
public sealed record ActionCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping, Piece? Piece = null)
{
}

// Object-oriented actors for move expansion and filtering. These are domain-agnostic
// and operate using delegates supplied for board interrogation and faction info.

// A minimal interface for any actor that can produce move candidates
public interface IActor
{
    IEnumerable<ActionCandidate> GetActionCandidates();
}

// Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
public interface IPolicy
{
    IEnumerable<ActionCandidate> Apply(IEnumerable<ActionCandidate> candidates);
}

// Concrete faction policy
public sealed class FactionPolicy
{
    private readonly (int X, int Y) _forward;
    public FactionPolicy((int X, int Y) forward) => _forward = forward;
    public (int X, int Y) GetForwardAxis() => _forward;
}

// FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
public sealed class FactionActor
{
    public FactionPolicy Policy { private set; get; }
    public FactionActor(FactionPolicy policy) => Policy = policy;
}

// CellActor: domain-agnostic representation of a board cell (row/col)
// CellActor now implements IMoveActor and may hold an optional PieceActor to which it delegates move expansion
public sealed class CellActor : IActor
{
    public int Row { get; }
    public int Col { get; }
    public PieceActor? OccupyingPiece { get; set; }

    public CellActor(int row, int col)
    {
        Row = row;
        Col = col;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        if (OccupyingPiece == null) yield break;
        foreach (ActionCandidate cand in OccupyingPiece.GetCandidates(Row, Col))
            yield return cand;
    }
}



// Concrete piece policy
public sealed class PiecePolicy
{
    private readonly IEnumerable<PatternDto> _basePatterns;
    public PiecePolicy(IEnumerable<PatternDto> basePatterns) => _basePatterns = basePatterns;

    public IEnumerable<PatternDto> GetPatterns()
    {
        foreach (PatternDto basePattern in _basePatterns)
        {
            foreach (PatternDto mirroredPattern in GetMirroredPatterns(basePattern))
            {
                yield return mirroredPattern;
            }
        }
    }

    private static IEnumerable<PatternDto> GetMirroredPatterns(PatternDto pattern)
    {
        yield return new PatternDto(pattern.Vector, MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return new PatternDto((-pattern.Vector.X, pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return new PatternDto((pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return new PatternDto((-pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);
    }
}


public sealed class PieceActor
{
    private readonly PiecePolicy _policy;
    private readonly FactionActor _faction;

    public PieceActor(PiecePolicy policy, FactionActor faction)
    {
        _policy = policy;
        _faction = faction;
    }

    //TODO: refactor to expand pattern deltas instead (without adding the starting position)
    // also, turn into arguments: the forward axis and the patterns collection
    public IEnumerable<ActionCandidate> GetCandidates(int fromRow, int fromCol)
    {
        (int X, int Y) forward = (1, 1);
        if (_faction != null) forward = _faction.Policy.GetForwardAxis();

        foreach (PatternDto p in _policy.GetPatterns())
        {
            int dx = p.Vector.X * forward.X;
            int dy = p.Vector.Y * forward.Y;
            int x = fromCol;
            int y = fromRow;
            int steps = 0;
            int maxSteps = 8;

            do
            {
                x += dx;
                y += dy;
                steps++;

                yield return new ActionCandidate(fromRow, fromCol, y, x, p, steps, p.Jumps);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
    {
        yield return (pattern.Vector, pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
    }
}

// BoardActor: composes piece actors for every piece on the board and applies board-level filters
public sealed class BoardActor : IActor
{
    private readonly IEnumerable<CellActor> _cells;
    private readonly Func<int, int, bool> _isInside;
    private readonly Func<int, int, object?> _getPieceAt;
    private readonly IPolicy? _policy;

    public BoardActor(IEnumerable<CellActor> cells, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
    {
        _cells = cells;
        _isInside = isInside;
        _getPieceAt = getPieceAt;
        _policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        return CandidateBuilder
            .FromCellActors(_cells, _isInside, _getPieceAt)
            .ApplyPolicy(_policy)
            .Build();
    }

}

public sealed class GameActor : IActor
{
    public GameState State { private get; set; }
    public GamePolicy Policy { private get; set; }

    public GameActor(GameState state, GamePolicy policy)
    {
        State = state;
        Policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        throw new NotImplementedException();
    }
}

public class PlayerActor
{
}

public class GameState
{
    int TurCount { get; set; }
    private readonly BoardActor _board;
    private readonly PlayerActor[] _players;
    public GameState(BoardActor board, PlayerActor[] players)
    {
        _board = board;
        _players = players;
    }
}

public class GamePolicy
{
}

// New core-level types implementing the Game -> Board -> Piece flow
public enum Faction { White, Black }

public sealed class Piece
{
    public int Row { get; private set; }
    public int Col { get; private set; }
    public PiecePolicy Policy { get; }
    public Faction Faction { get; }

    public Piece(PiecePolicy policy, Faction faction, int row, int col)
    {
        Policy = policy;
        Faction = faction;
        Row = row;
        Col = col;
    }

    public IEnumerable<ActionCandidate> GetActions(Board board)
    {
        (int X, int Y) forward = (1, 1);

        // Note: using existing pattern expansion from PiecePolicy
        foreach (PatternDto p in Policy.GetPatterns())
        {
            int dx = p.Vector.X * forward.X;
            int dy = p.Vector.Y * forward.Y;
            int x = Col;
            int y = Row;
            int steps = 0;
            int maxSteps = Math.Max(board.Rows, board.Cols);

            do
            {
                x += dx;
                y += dy;
                steps++;

                yield return new ActionCandidate(Row, Col, y, x, p, steps, p.Jumps, this);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    public void MoveTo(int newRow, int newCol)
    {
        Row = newRow;
        Col = newCol;
    }
}

public sealed class Board
{
    private readonly List<Piece> _pieces = new();
    public int Rows { get; }
    public int Cols { get; }

    public Board(int rows, int cols)
    {
        Rows = rows;
        Cols = cols;
    }

    public void Reset()
    {
        _pieces.Clear();
    }

    public void AddPiece(Piece p) => _pieces.Add(p);

    public Piece? PieceAt(int row, int col) => _pieces.FirstOrDefault(p => p.Row == row && p.Col == col);

    public void Apply(ActionCandidate action)
    {
        Piece? p = action.Piece ?? PieceAt(action.FromRow, action.FromCol);
        if (p == null) return;
        p.MoveTo(action.ToRow, action.ToCol);
    }

    public IEnumerable<ActionCandidate> GetActions()
    {
        return _pieces.SelectMany(p => p.GetActions(this))
                      .Filter(a => IsInside(a.FromRow, a.FromCol))
                      .Filter(a => IsInside(a.ToRow, a.ToCol));
    }

    public bool IsInside(int row, int col) => row >= 0 && row < Rows && col >= 0 && col < Cols;
}

public sealed class Game
{
    private readonly Board _board;
    public int TurnCount { get; private set; }
    public Faction TurnFaction { get; private set; }

    public Game(Board board)
    {
        _board = board;
        Reset();
    }

    public void Reset()
    {
        TurnCount = 0;
        TurnFaction = Faction.White;
        _board.Reset();
    }

    public void Apply(ActionCandidate action) => _board.Apply(action);

    public IEnumerable<ActionCandidate> GetActions()
    {
        return _board.GetActions()
                     .Filter(a => a.Piece != null && a.Piece.Faction == TurnFaction)
                     .Filter(a => !IsBlocked(a))
                     .Filter(a => true) // placeholder for empty captures
                     .Filter(a => true) // placeholder for checking moves
                     .Explode(a => new[] { a }); // placeholder for castle explosion
    }

    private bool IsBlocked(ActionCandidate a)
    {
        var dest = _board.PieceAt(a.ToRow, a.ToCol);
        return dest != null && a.Piece != null && dest.Faction == a.Piece.Faction;
    }

}

public static class MoveExtensions
{
    public static IEnumerable<T> Filter<T>(this IEnumerable<T> source, Func<T, bool> predicate)
        => source.Where(predicate);

    public static IEnumerable<T> Explode<T>(this IEnumerable<T> source, Func<T, IEnumerable<T>> generator)
        => source.SelectMany(generator);
}