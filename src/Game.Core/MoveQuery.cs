using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Core.Wip;
// Domain-agnostic pattern DTO used by the core move query system
public record PatternDto((int X, int Y) Vector,
    MirrorBehavior Mirrors = MirrorBehavior.All,
    RepeatBehavior Repeats = RepeatBehavior.Repeatable,
    CaptureBehavior Captures = CaptureBehavior.MoveOrCapture,
    bool ForwardOnly = false,
    bool Jumps = false
);

[Flags]
public enum MirrorBehavior { None = 0, Horizontal = 1, Vertical = 2, All = Horizontal | Vertical }
public enum RepeatBehavior { NotRepeatable, Repeatable, RepeatableOnce }
public enum CaptureBehavior { MoveOnly, CaptureOnly, MoveOrCapture, CastleOnly }

// A candidate move generated by the builder before final filtering
public sealed record ActionCandidate(int FromRow, int FromCol, int ToRow, int ToCol, PatternDto Pattern, int Steps, bool IsJumping, List<CellActor> TraversedCells, Piece? Piece = null)
{
}

// Object-oriented actors for move expansion and filtering. These are domain-agnostic
// and operate using delegates supplied for board interrogation and faction info.

// A minimal interface for any actor that can produce move candidates
public interface IActor
{
    IEnumerable<ActionCandidate> GetActionCandidates();
}

// Policy abstraction: policies accept a candidate stream and return a (possibly filtered/modified) stream
public interface IPolicy
{
    IEnumerable<ActionCandidate> Apply(IEnumerable<ActionCandidate> candidates);
}

// Concrete faction policy
public sealed class FactionPolicy
{
    private readonly (int X, int Y) _forward;
    public FactionPolicy((int X, int Y) forward) => _forward = forward;
    public (int X, int Y) GetForwardAxis() => _forward;
}

// FactionActor: encapsulates faction-specific behavior and uses an IFactionPolicy
public sealed class FactionActor
{
    public FactionPolicy Policy { private set; get; }
    public FactionActor(FactionPolicy policy) => Policy = policy;
}

// CellActor: domain-agnostic representation of a board cell (row/col)
// CellActor now implements IMoveActor and may hold an optional PieceActor to which it delegates move expansion
public sealed class CellActor : IActor
{
    public int Row { get; }
    public int Col { get; }
    public PieceActor? OccupyingPiece { get; set; }

    public CellActor(int row, int col)
    {
        Row = row;
        Col = col;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        if (OccupyingPiece == null) yield break;
        foreach (ActionCandidate cand in OccupyingPiece.GetCandidates(Row, Col))
            yield return cand;
    }
}



// Concrete piece policy
public sealed class PiecePolicy
{
    private readonly IEnumerable<PatternDto> _basePatterns;
    public PiecePolicy(IEnumerable<PatternDto> basePatterns) => _basePatterns = basePatterns;

    public IEnumerable<PatternDto> GetPatterns()
    {
        foreach (PatternDto basePattern in _basePatterns)
        {
            foreach (PatternDto mirroredPattern in GetMirroredPatterns(basePattern))
            {
                yield return mirroredPattern;
            }
        }
    }

    private static IEnumerable<PatternDto> GetMirroredPatterns(PatternDto pattern)
    {
        yield return new PatternDto(pattern.Vector, MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return new PatternDto((-pattern.Vector.X, pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return new PatternDto((pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return new PatternDto((-pattern.Vector.X, -pattern.Vector.Y), MirrorBehavior.None, pattern.Repeats, pattern.Captures, pattern.ForwardOnly, pattern.Jumps);
    }
}


public sealed class PieceActor
{
    private readonly PiecePolicy _policy;
    private readonly FactionActor _faction;

    public PieceActor(PiecePolicy policy, FactionActor faction)
    {
        _policy = policy;
        _faction = faction;
    }

    //TODO: refactor to expand pattern deltas instead (without adding the starting position)
    // also, turn into arguments: the forward axis and the patterns collection
    public IEnumerable<ActionCandidate> GetCandidates(int fromRow, int fromCol)
    {
        (int X, int Y) forward = (1, 1);
        if (_faction != null) forward = _faction.Policy.GetForwardAxis();

        foreach (PatternDto p in _policy.GetPatterns())
        {
            int dx = p.Vector.X * forward.X;
            int dy = p.Vector.Y * forward.Y;
            int x = fromCol;
            int y = fromRow;
            int steps = 0;
            int maxSteps = 8;

            var traversedCells = new List<CellActor>();
            do
            {
                x += dx;
                y += dy;
                steps++;

                var cell = new CellActor(y, x);
                traversedCells.Add(cell);
                var traversedCellsClone = new List<CellActor>(traversedCells);

                yield return new ActionCandidate(fromRow, fromCol, y, x, p, steps, p.Jumps, traversedCellsClone);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    private static IEnumerable<((int X, int Y) Vector, MirrorBehavior Mirrors)> GetMirroredVectors(PatternDto pattern)
    {
        yield return (pattern.Vector, pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Horizontal) && pattern.Vector.X != 0)
            yield return ((-pattern.Vector.X, pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.Vertical) && pattern.Vector.Y != 0)
            yield return ((pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);

        if (pattern.Mirrors.HasFlag(MirrorBehavior.All) && pattern.Vector.X != 0 && pattern.Vector.Y != 0)
            yield return ((-pattern.Vector.X, -pattern.Vector.Y), pattern.Mirrors);
    }
}

// BoardActor: composes piece actors for every piece on the board and applies board-level filters
public sealed class BoardActor : IActor
{
    private readonly IEnumerable<CellActor> _cells;
    private readonly Func<int, int, bool> _isInside;
    private readonly Func<int, int, object?> _getPieceAt;
    private readonly IPolicy? _policy;

    public BoardActor(IEnumerable<CellActor> cells, Func<int, int, bool> isInside, Func<int, int, object?> getPieceAt, IPolicy? policy = null)
    {
        _cells = cells;
        _isInside = isInside;
        _getPieceAt = getPieceAt;
        _policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        return CandidateBuilder
            .FromCellActors(_cells, _isInside, _getPieceAt)
            .ApplyPolicy(_policy)
            .Build();
    }

}

public sealed class GameActor : IActor
{
    public GameState State { private get; set; }
    public GamePolicy Policy { private get; set; }

    public GameActor(GameState state, GamePolicy policy)
    {
        State = state;
        Policy = policy;
    }

    public IEnumerable<ActionCandidate> GetActionCandidates()
    {
        throw new NotImplementedException();
    }
}

public class PlayerActor
{
}

public class GameState
{
    int TurCount { get; set; }
    private readonly BoardActor _board;
    private readonly PlayerActor[] _players;
    public GameState(BoardActor board, PlayerActor[] players)
    {
        _board = board;
        _players = players;
    }
}

public class GamePolicy
{
}

// New core-level types implementing the Game -> Board -> Piece flow
public enum Faction { White, Black }

public sealed class Piece
{
    public int Row { get; private set; }
    public int Col { get; private set; }
    public PiecePolicy Policy { get; }
    public Faction Faction { get; }

    public Piece(PiecePolicy policy, Faction faction, int row, int col)
    {
        Policy = policy;
        Faction = faction;
        Row = row;
        Col = col;
    }

    public IEnumerable<ActionCandidate> GetActions(int rows, int cols)
    {
        // Determine forward axis based on faction: white moves +Y, black moves -Y
        (int X, int Y) forward = Faction == Faction.White ? (1, 1) : (1, -1);

        // Note: using existing pattern expansion from PiecePolicy
        foreach (PatternDto p in Policy.GetPatterns())
        {
            int dx = p.Vector.X * forward.X;
            int dy = p.Vector.Y * forward.Y;
            int x = Col;
            int y = Row;
            int steps = 0;
            int maxSteps = Math.Max(rows, cols);

            var traversedCells = new List<CellActor>();
            do
            {
                x += dx;
                y += dy;
                steps++;

                var cell = new CellActor(y, x);
                traversedCells.Add(cell);
                var traversedCellsClone = new List<CellActor>(traversedCells);

                yield return new ActionCandidate(Row, Col, y, x, p, steps, p.Jumps, traversedCellsClone, this);

                if (p.Repeats == RepeatBehavior.NotRepeatable || (p.Repeats == RepeatBehavior.RepeatableOnce && steps == 1) || p.Jumps)
                    break;

                if (steps >= maxSteps) break;

            } while (true);
        }
    }

    public void MoveTo(int newRow, int newCol)
    {
        Row = newRow;
        Col = newCol;
    }
}

public sealed class Board
{
    private readonly List<Piece> _pieces = new();
    public int Rows { get; }
    public int Cols { get; }

    public Board(int rows, int cols)
    {
        Rows = rows;
        Cols = cols;
    }

    public void Reset()
    {
        _pieces.Clear();
    }

    public void AddPiece(Piece p) => _pieces.Add(p);

    public Piece? PieceAt(int row, int col) => _pieces.FirstOrDefault(p => p.Row == row && p.Col == col);

    public void Apply(ActionCandidate action)
    {
        Piece? p = action.Piece ?? PieceAt(action.FromRow, action.FromCol);
        if (p == null) return;
        p.MoveTo(action.ToRow, action.ToCol);
    }
    public IEnumerable<ActionCandidate> GetActionsLinq()
    {
        const int maxExplodeSteps = 8;

        int PieceId(int row, int col) => HashCode.Combine(row, col);
        int DirectionId(PatternDto d) => HashCode.Combine(d.Vector.X, d.Vector.Y, d.Captures);

        // 1️⃣ Generate all exploded move targets (piece × direction × step)
        var exploded =
            from Piece p in _pieces
            from PatternDto d in p.Policy.GetPatterns()
            from int step in Enumerable.Range(1, maxExplodeSteps)
            let toRow = p.Row + d.Vector.X * step
            let toCol = p.Col + d.Vector.Y * step
            select new
            {
                Piece = p,
                Direction = d,
                Step = step,
                ToRow = toRow,
                ToCol = toCol,
                Occupying = PieceAt(toRow, toCol)
            };

        // 2️⃣ Keep only cells inside the board
        var bounded =
            from e in exploded
            select e;

        // 3️⃣ Compute, per (piece,direction), where the *first occupied* cell is
        var firstBlocks =
            from e in bounded
            where e.Occupying != null
            group e by new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } into g
            select new
            {
                g.Key.Id,
                g.Key.Id1,
                FirstBlockStep = g.Min(x => x.Step)
            };

        // 4️⃣ Join exploded moves with the first-block info
        var joined =
            from e in bounded
            join fb in firstBlocks
                on new { Id = PieceId(e.Piece.Row, e.Piece.Col), Id1 = DirectionId(e.Direction) } equals new { fb.Id, fb.Id1 }
                into fbGroup
            from fb in fbGroup.DefaultIfEmpty()
            select new
            {
                e,
                FirstBlockStep = fb?.FirstBlockStep
            };

        // 5️⃣ Filter to keep only steps before the first occupied
        var visible =
            from j in joined
            where j.FirstBlockStep == null || j.e.Step <= j.FirstBlockStep
            select j.e;

        // 6️⃣ Convert to ActionCandidates and filter final legality
        var legal =
            from v in visible
            where IsValidTarget(v.ToRow, v.ToCol, v.Direction.Captures)
               && IsValidMovePath(v.ToRow, v.ToCol, v.Direction.Captures)
            select new ActionCandidate(
                v.Piece.Row,
                v.Piece.Col,
                v.ToRow,
                v.ToCol,
                v.Direction,
                v.Step,

                v.Direction.Jumps,
                new List<CellActor>()
            );

        return legal;
    }

    public IEnumerable<ActionCandidate> GetActions()
    {
        // Inline per-piece direction processing (bounds/occupancy blocking) and
        // optionally parallelize across pieces to "explode" candidates like a Spark job.
        // Limit per-direction expansion to 8 steps for performance/control.
        const int maxExplodeSteps = 8;

        IEnumerable<ActionCandidate> expanded = _pieces
            // parallelize the piece-level work to distribute expansion across cores
            .AsParallel()
            // keep ordering predictable; remove AsOrdered() if you don't need determinism
            .AsOrdered()
            .SelectMany(p =>
            {
                var results = new List<ActionCandidate>();
                ActionCandidate? previous = null;
                bool directionBlocked = false;

                foreach (var cand in p.GetActions(Rows, Cols))
                {
                    // Reset blocking when pattern/direction changes
                    if (previous == null || !ReferenceEquals(previous.Pattern, cand.Pattern) || cand.Steps <= previous.Steps)
                        directionBlocked = false;

                    previous = cand;

                    if (directionBlocked) continue;

                    // Cap expansion per-direction to maxExplodeSteps
                    if (cand.Steps > maxExplodeSteps)
                    {
                        directionBlocked = true;
                        continue;
                    }

                    // Check bounds and block further steps in this direction if outside
                    if (!IsInside(cand.ToRow, cand.ToCol))
                    {
                        directionBlocked = true;
                        continue;
                    }

                    var occupying = PieceAt(cand.ToRow, cand.ToCol);

                    results.Add(cand);

                    // If occupied, block further steps in this direction
                    if (occupying != null)
                        directionBlocked = true;
                }

                return results;
            })
            .AsSequential();

        return expanded
                          .Filter(a => IsInside(a.FromRow, a.FromCol))
                          .Filter(a => IsInside(a.ToRow, a.ToCol))
                          .Filter(a => IsValidTarget(a.ToRow, a.ToCol, a.Pattern.Captures))
                          .Filter(a => a.TraversedCells.All(cell => IsValidMovePath(cell.Row, cell.Col, a.Pattern.Captures)));
    }

    public bool IsInside(int row, int col) => row >= 0 && row < Rows && col >= 0 && col < Cols;

    public bool IsValidTarget(int row, int col, CaptureBehavior captures)
    {
        Piece? target = PieceAt(row, col);
        bool isOccupied = target != null;

        return captures switch
        {
            CaptureBehavior.MoveOnly => !isOccupied,
            CaptureBehavior.CaptureOnly => isOccupied,
            CaptureBehavior.MoveOrCapture => true,
            _ => false,
        };
    }
    public bool IsValidMovePath(int row, int col, CaptureBehavior captures)
    {
        if (captures == CaptureBehavior.MoveOnly)
        {
            Piece? target = PieceAt(row, col);
            bool isOccupied = target != null;
            return !isOccupied;
        }
        return true;
    }
}

public sealed class Game
{
    private readonly Board _board;
    public int TurnCount { get; private set; }
    public Faction TurnFaction { get; private set; }

    public Game(Board board)
    {
        _board = board;
        Reset();
    }

    public void Reset()
    {
        TurnCount = 0;
        TurnFaction = Faction.White;
        _board.Reset();
    }

    public void Apply(ActionCandidate action) => _board.Apply(action);

    public IEnumerable<ActionCandidate> GetActions()
    {
        return _board.GetActions()
                     .Filter(a => a.Piece != null && a.Piece.Faction == TurnFaction)
                     .Filter(a => !IsBlocked(a))
                     .Filter(a => true) // placeholder for empty captures
                     .Filter(a => true) // placeholder for checking moves
                     .Explode(a => new[] { a }); // placeholder for castle explosion
    }

    private bool IsBlocked(ActionCandidate a)
    {
        var dest = _board.PieceAt(a.ToRow, a.ToCol);
        return dest != null && a.Piece != null && dest.Faction == a.Piece.Faction;
    }

}

public static class MoveExtensions
{
    public static IEnumerable<T> Filter<T>(this IEnumerable<T> source, Func<T, bool> predicate)
        => source.Where(predicate);

    public static IEnumerable<T> Explode<T>(this IEnumerable<T> source, Func<T, IEnumerable<T>> generator)
        => source.SelectMany(generator);
}